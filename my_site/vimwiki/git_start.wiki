%toc 目录
<hr />
== 取得项目的Git仓库 ==
# 在工作目录下初始化新仓库
{{{
对现有项目的某个项目开始用Git管理，只需到此项目所在的目录,执行:
$ git init
初始化之后，在当前目录下会出现一个名为.git的目录，所有Git需要的数据和资源都存放在这个目录中。
不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没开始跟踪管理项目中的任何一个文件。
如果当前有几个文件想要纳入版本控制，需要先用git add命令告诉Git开始对这些文件进行跟踪，然后提交:
$ git add *.c
$ git add README
$ git commit -m 'initial project version'
看不明白吧，别急嘛，待会儿解释每一条指令的意思。
不过现在，你已经得到看了一个实际维护着若干文件的Git仓库
}}}
# 从现有的仓库克隆
相对开源项目贡献一份你的力量吗？尽管力量很微小，嘿嘿
可以先把该项目的Git仓库复制一份出来，这就需要 `git clone` 命令咯

例如，我们克隆一下Ruby的代码仓库Grit
{{{
$ git clone git://github.com/schacon/grit.git
这会在当前目录下创建一个grit的目录，其中包含一个.git的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。

$ git clone git://github.com/schacon/grit.git mygrit
这回生成一个mygrit的目录，只是名字不同，其他和上面一样
}}}
Git支持多种数据传输协议。之前的例子使用的是`git://`协议
不过你也可以用`http(s)://`或者`user@server:/path.git`表示的SSH传输协议.

具体后讲述，暂时封锁你的好奇心吧

== 记录每次更新到仓库 ==
=== 检查文件状态 ===
文件状态无外乎两种状态:已追踪或未跟踪

工作一段时间后，文件的状态可能是未更新，已修改或者已经放入暂存区域。

而其他所有的文件则属于未更总文件，他们既没有上次更新时的快照，也不再当前暂存区域

初次克隆某个仓库，工作目录中的所有文件都属于已跟踪文件，且状态为未修改
{{{
查看当前仓库的追踪状态
$ git status
}}}
=== 跟踪新文件和暂存文件 ===
使用命令 _git add <file>_ 开始追踪一个新文件。所以，要跟踪README文件,运行:
{{{
$ git add README
}}}
其实， _git add_ 的潜台词就是把目标文件快照放入暂存区域，也就是add file into staged area

同时，未曾跟踪过的文件标记为需要跟踪
=== 忽略某些文件 ===
{{{
暂时先不说这里，我按照帮助文档，没有什么效果，可能是哪里有点问题，等到有时间了再深究
}}}
=== 查看已经暂存和未曾暂存的更新 ===
* 查看工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没暂存起来的变化内容
{{{
$ git diff
}}}
* 查看已经暂存的文档和上次提交时的快照之间的差异
{{{
$ git diff --staged
}}}
=== 提交更新 ===
{{{
$ git commit
弹出一个默认编辑器的窗口，等待你输入提交信息，一般在第一行会有空行
含有#号的是注释行
$ git commit -m '提交信息'
这个是直接在命令行添加提交信息的命令
}}}
=== 跳过使用暂存区域 ===
尽管我们每次提交的时候都很小心翼翼，但有时候这么坐略显繁琐

Git提供了一个跳过使用暂存区域的方式，只要提交的时候，给git commit加上0-a的选项即可,此时Git怎么工作呢？

Git会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤
{{{
$ git -a -m '提交信息'
}}}
=== 移除文件 ===
* 移除Git中的文件，然后提交(文件会从暂存区域删除，并且工作目录中的文件也会删除)
{{{
$ git rm file
$ git commit -m 'deleted file'
}}} 
* 删除暂存区域的记录，保存工作区域的文件
{{{
$ git rm --cached file
}}}
* 强行删除放入暂存区域的记录，工作区域的文件也被删除
{{{
# git rm -f file
}}}
* 递归删除
{{{
递归删除log和log子目录下的.log
$ git rm log/\.log
若是log下文件就只有.log格式的文件，那么最后log目录也会消失
'\'是递归匹配
}}}
=== 重命名文件 ===
{{{
$ git mv file1 file2
相当于下面三条命令:
$ mv file1 file2
$ git rm file1
$ git add file2
}}}
=== 查看提交历史 ===
{{{
$ git log	
显示每次更新的SHA-1校验和，作者和email，提交时间，最后缩进一个段落显示提交说明
$ git log -p 2
显示每次提交的内容差异，仅显示最近的两次更新
$ git log --stat
仅显示增改行数统计
$ git log pretty=format"%an %ar"
显示作者的名字，作者的修订日期，按多久以前方式显示
具体请看下面的format格式占位符号
}}}
[[git_log_format|format格式占位符]]
* 作者(author)和提交者(committer)
{{{
你一定奇怪_作者(author)和提交者(committer)_之间究竟有何差别,
其实作者指的是实际作出修改的人,提交者指的是最后将此工作成果提交到仓库的人。
所以,当你为某个项目发布补丁,然后某个核心成员将你的补丁并入项目时,你就是作者,而那个核心成员就是提交者。
}}}
=== 撤销操作 ===
==== 重新提交 ====
提交信息写错了，怎么办呢？漏了几个文件怎么办？

那就撤销呗
{{{
$ git commit --amend
此命令将使用当前的暂存区域快照提交。
如果刚才提交完没有作任何改动,直接运行此命令的话,相当于有机会重新编辑提交说明,但将要提交的文件快照和之前的一样。
启动文本编辑器后,会看到上次提交时的说明,编辑它确认没问题后保存退出,就会使用新的提交说明覆盖刚才失误的提交。
如果刚才提交时忘了暂存某些修改,可以先补上暂存操作,然后再运行 --amend 提交
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
}}}
==== 取消已经暂存的文件 ====
{{{
$ git reset HEAD file
}}}
==== 取消对文件的更改 ====
假如不小心删除了你心爱的文件(假如该文件曾经提交过),怎么办?

假如不下心修改了一个重要的文件，怎么办？

喔，不用担心，来使用我吧:
{{{
git checkout -- file
}}}













